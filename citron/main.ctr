Broom memoryLimit: 1024 * 1024 * 1024 * 8.

import
  Utils/zmq: \*
  Utils/tools: \*
  Utils/hmac: \*.

import Utils/JupyterIOPubStream: \*.
import Library/Data/IO/Pen: 'pPen'.

import Library/Data/Json.

Json on: 'serialize!:' do: {:obj
  var res is serialize: obj, escape: '\n\a\b\f\r\t\v'.
  {^res endsWith: '\x0'.} whileTrue: {
    res is res from: 0 length: res length - 1.
  }.
  ^res.
}.

var DEBUG is False not.

var log is {:stuff
  DEBUG ifFalse: {^Nil.}.

  Pen magenta write: '[CitronKernel] [Log] [${{Shell call: 'date +%T.%3N', trim}}$] ', resetColor.
  Pen write: stuff.
  Pen brk.
}.
log on: 'process:' do: {:str
  ^me[str].
}.

#:language XFrozen

var createZmq is {\:qq:type:scm :rp:rv:rv2
    rp is zmq_socket[qq, type].
    rv is zmq_bind[rp, scm].
    rv = -1 ifTrue: {
      thisBlock error: zmq_strerror_s[] readCString.
    }.
    rv is frozen _ is CTypes sint set: 1.
    rv2 is frozen _ is CTypes sint set: 4.
    zmq_setsockopt[rp, ZMQ_IMMEDIATE, rv, rv2].
    # Pen writeln: 'create socket $$type for $$scm'.
    rp.
}.

var DELIM is '<IDS|MSG>'.

var KERNEL-INFO is Map new
  put: '5.3.0' at: 'protocol_version',
  put: 'Citron Jupyter Kernel' at: 'implementation',
  put: '0.0.1' at: 'implementation_version',
  put: (
    Map new
      put: 'Citron' at: 'name',
      put: Reflect version at: 'version',
      put: 'application/x-citron' at: 'mimetype',
      put: '.ctr' at: 'file_extension'
  ) at: 'language_info',
  put: 'Citron ${{Reflect compilerInfo}}$ Jupyter Kernel' at: 'banner',
  put: [] at: 'help_links'
.

var send is {:key:socket:uuid:header:parent-header:metadata:content
  var data is Nil.
  var timeF is Clock executionSeconds: {
    var signature is getSignature[key, header + parent-header + metadata + content].
    data is [
      uuid,
      const DELIM,
      signature,
      header,
      parent-header,
      metadata,
      content
    ].
  }.
  log ['creating data took ${{timeF * 1000}}$ ms'].
  timeF is Clock executionSeconds: {
    zmq_send_all[socket, data, 0].
  }.
  log ['sending data took ${{timeF * 1000}}$ ms'].
}.

var pub is {:header-:state:parent-header
  const send[key, socket-iopub, '\x66', header-['status'], parent-header, '{}', '{"execution_state":' + (Json serialize!: state) + '}' ].
}.

var pub-busy is {:header-:parent-header const pub[header-, 'busy', parent-header]. }.
var pub-idle is {:header-:parent-header const pub[header-, 'idle', parent-header]. }.

var heartbeat-handler is {:self:rlen:str
  # Pen green write: '[CitronKernel] ', resetColor writeln: 'heartbeat message recv ' + rlen + ' bytes'.
  zmq_send[socket-heartbeat, str, rlen, 0].
}.

var general-handler is {:self:*sockets
  var socks-and-procs is sockets fmap: {:sock ^[sock, {:socket:parts
      log ['socket $$socket receied data'].
      var uuid is parts head.
      var delimiter is parts @ 1.
      var signature is parts @ 2.
      var header is Json parse: parts @ 3.
      var parent-header is Json parse: parts @ 4.
      var metadata is Json parse: parts @ 5.
      var content is Json parse: parts @ 6.

      var msg-type is header @ 'msg_type'.
      var msg-username is header @ 'username'.
      var msg-session is header @ 'session'.
      var msg-version is header @ 'version'.

      log 'Parsed parts'.
      log ['message type $$msg-type with header $$header and content $$content'].

      var header- is makeHeader[msg-username, msg-session, msg-version].
      log 'Dispatch begin'.
      pub-busy[header-, parts @ 3].

      dispatch[msg-type][socket, uuid, header-, parts @ 3, parts @ 5, content].

      pub-idle[header-, parts @ 3].
      log 'Dispatch end'.
    }].
  }.
  {
    log 'General Handler begin'.
    zmq_race_recv_parts applyAll: socks-and-procs.

    log 'General Handler sleep start'.
    Clock wait: 10 msec.
    log 'General Handler sleep end'.
  } forever.
}.


var text/plain is {:x ^Map new put: x toString at: 'text/plain'. }.

var EvalContext is Map cnew: {
    JupyterPen => pPen for: JupyterIOPubStream.
}.

var reply-execute-request is {:socket:uuid:header-:parent-header:metadata:content
  var code is
  '{\n' +
    (content @ 'code') +
  '\n}.'.
  log 'Generated code'.

  var silent            is content @ 'silent'.
  var store-history     is content @ 'store_history'.
  var user-expressions  is content @ 'user_expressions'.
  var allow-stdin       is content @ 'allow_stdin'.
  var stop-on-error     is content @ 'stop_on_error'.

  var empty-object is Map new.
  var counter is exec-counter[].
  var send- is {\:socket:msg-type:content
      send[key, socket, uuid, header-[msg-type], parent-header, metadata, (Json serialize!: content)].
  }.

  log ['Started execution of $$counter'].

  JupyterIOPubStream
    header-: header-,
    parent-header: parent-header.

  log ['Set IOPubStream $$JupyterIOPubStream headers to $$header- and $$parent-header'].
  # Thread new: {
    log ['Started execution thread for expr $$counter'].
    var res is {
      var cobjs is AST parse: code.
      var res is Reflect run: {:cobjs:EvalContext
        var res is Nil.
        cobjs each: {:_:cobj
          res is cobj evaluateInContext: EvalContext.
        }.
        ^res.
      } inContextAsMain: const EvalContext arguments: [cobjs @ 0 @ 1, const EvalContext].
      ^[\Ok, res].
    } catch: {:e
      # Pen red writeln: [e, e exceptionInfo], resetColor.
      ^[\Error, e].
    }, run.

    log ['Executed code $$code'].

    log ['Sending info back for context $$counter'].
    send-[socket-iopub, 'execute_input', (Map new put: (content @ 'code') at: 'code', put: counter at: 'execution_count')].

    log 'sent the code info back'.

    res head = \Error ifTrue: {
      send-[socket-iopub, 'error', (Map new
        put: 'Exception' at: 'ename',
        put: res last at: 'evalue',
        put: [] at: 'traceback')].
      send-[socket, 'execute_reply', (Map new
        put: 'error' at: 'status',
        put: counter at: 'execution_count',
        put: 'Exception' at: 'ename',
        put: res last at: 'evalue',
        put: [] at: 'traceback',
        put: [] at: 'payload')].
    } ifFalse: {
      send-[socket, 'execute_reply', (Map new
        put: 'ok' at: 'status',
        put: counter at: 'execution_count',
        put: [] at: 'payload')].
      send-[socket-iopub, 'execute_result', (Map new
        put: text/plain[res last] at: 'data',
        put: counter at: 'execution_count',
        put: empty-object at: 'metadata')].
    }.

    log ['Responded to the execute request $$res'].
    log ['Killing off thread for context $$counter'].
  # }, detach run.
}.
# send kernel-info
var reply-kernel-info-request is {:socket:uuid:header-:parent-header:metadata:content
  log 'ReplyKernelInfoRequest start'.
  send[key, socket-shell, uuid, header-['kernel_info_reply'], parent-header, metadata, (Json serialize!: KERNEL-INFO)].
  log 'ReplyKernelInfoRequest end'.
}.

var shutdown is {:socket:uuid:header-:parent-header:metadata:content
  log 'Closing all sockets...'.
  zmq-session-sockets fmap: zmq_close.
  zmq_ctx_destroy[zmq-context].
  log 'Now dying as per request'.
  Program exit.
}.

var ignore-request is { log 'Ignored some request'. }.

var dispatch-route is Map new
  put: reply-kernel-info-request at: 'kernel_info_request',
  put: reply-execute-request     at: 'execute_request',
  put: shutdown                  at: 'shutdown_request',
  put: ignore-request            at: 'comm_info_request'.

var dispatch is {:msg-type
  # Pen green write: '[CitronKernel] ', resetColor writeln: 'dispatch $$msg-type'.
  var res is const dispatch-route at: msg-type.
  res isNil ifTrue: {
    # Pen red writeln: '\n*WW* unknown message type: $$msg-type \n\n', resetColor.
    ^ignore-request.
  } ifFalse: {
    ^res.
  }.
}.

var startWorld is {:config-path
    log 'Starting world'.
    var config is Json parse: (File new: config-path, read).
    # Pen writeln: config.
    var scm is (config @ 'transport') + '://' + (config @ 'ip') + ':'.
    var addport is \:&port scm + port.

    # get config values
    var control-port     is config @ 'control_port'.
    var shell-port       is config @ 'shell_port'.
    var transport        is config @ 'transport'.
    var signature-scheme is config @ 'signature_scheme'.
    var stdin-port       is config @ 'stdin_port'.
    var heartbeat-port   is config @ 'hb_port'.
    var ip               is config @ 'ip'.
    var iopub-port       is config @ 'iopub_port'.
    var key              is config @ 'key'.

    # Execution context counter
    var exec-counter is { ^(frozen count is 0) +=: 1. }.
    # zmq context
    var zmq-context is zmq_ctx_new[].

    var socket-shell     is const createZmq[zmq-context, ZMQ_ROUTER, addport[shell-port    ]].
    var socket-control   is const createZmq[zmq-context, ZMQ_ROUTER, addport[control-port  ]].
    var socket-iopub     is const createZmq[zmq-context, ZMQ_PUB,    addport[iopub-port    ]].
    var socket-stdin     is const createZmq[zmq-context, ZMQ_ROUTER, addport[stdin-port    ]].

    var pub-text is {:socket:header-:text:stream:parent-header
      const send[const key, socket, '\x66', header-['stream'], parent-header, '{}', (Json serialize!: (Map new put: text at: 'text', put: stream at: 'name'))].
    }.

    var pub-text-stdout is {:socket:header-:parent-header:text
      const pub-text[socket, header-, text, 'stdout', parent-header].
    }.

    JupyterIOPubStream
      socket: socket-iopub,
      sender: pub-text-stdout.

    var zmq-session-sockets is Array <
      socket-shell ;
      socket-control ;
      socket-iopub ;
      socket-stdin .

    Thread new: {
      var zmq-context is zmq_ctx_new[].
      var socket-heartbeat is const createZmq[zmq-context, ZMQ_REP,    addport[heartbeat-port]].
      log 'Heartbeat thread start'.
      {
        var msg is zmq_recv_str[socket-heartbeat].
        log ['Heartbeat message received $$msg'].
        zmq_send[socket-heartbeat, msg, msg bytes, 0].
        log 'Heartbeat message echoed back'.
      } forever.
    }, run.
    # Pen writeln: 'Starting general handler'.
    general-handler[socket-shell, socket-control].
}.

var cfile is Program argument: 2.
# Pen writeln: 'start with config file $$cfile'.
startWorld[cfile].

log 'WERE GONNA DIEEEEEEEEEEEE!!!'.
